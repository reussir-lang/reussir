//===-- ReussirAttrs.td - Reussir dialect attributes -------*- tablegen -*-===//
//
// Part of the Reussir project, dual licensed under the Apache License v2.0 or
// the MIT License.
// SPDX-License-Identifier: Apache-2.0 OR MIT
//
//===----------------------------------------------------------------------===//
//
// This file defines the Reussir dialect attributes.
//
//===----------------------------------------------------------------------===//

#ifndef REUSSIR_IR_REUSSIRATTRS_TD
#define REUSSIR_IR_REUSSIRATTRS_TD

include "Reussir/IR/ReussirDialect.td"
include "mlir/IR/EnumAttr.td"

class ReussirAttr<string name, string attrMnemonic, list<Trait> traits = [],
  string baseCppClass = "::mlir::Attribute">
    : AttrDef<ReussirDialect, name, traits, baseCppClass> {
  let mnemonic = attrMnemonic;
}

//===----------------------------------------------------------------------===//
// Atomicity Attributes
//===----------------------------------------------------------------------===//
def AK_Normal : I32EnumAttrCase<"normal", 0>;
def AK_Atomic : I32EnumAttrCase<"atomic", 1>;
def AtomicKind
    : I32EnumAttr<"AtomicKind", "atomic kind", [AK_Normal, AK_Atomic]> {
  let cppNamespace = "::reussir";
}

//===----------------------------------------------------------------------===//
// Capability Attributes
//===----------------------------------------------------------------------===//
def CAP_Default : I32EnumAttrCase<"unspecified", 0>;
def CAP_Value : I32EnumAttrCase<"value", 1>;
def CAP_Shared : I32EnumAttrCase<"shared", 2>;
def CAP_Flex : I32EnumAttrCase<"flex", 3>;
def CAP_Rigid : I32EnumAttrCase<"rigid", 4>;
def CAP_Field : I32EnumAttrCase<"field", 5>;
def CAP_Regional : I32EnumAttrCase<"regional", 6>;


def Capability : I32EnumAttr<"Capability", "capability",
                             [CAP_Default, CAP_Value, CAP_Shared, CAP_Flex,
                              CAP_Rigid, CAP_Field, CAP_Regional]> {
  let cppNamespace = "::reussir";
}

//===----------------------------------------------------------------------===//
// Record Kind Attributes
//===----------------------------------------------------------------------===//
def RK_Struct : I32EnumAttrCase<"compound", 0>;
def RK_Enum : I32EnumAttrCase<"variant", 1>;

def RecordKind
    : I32EnumAttr<"RecordKind", "record kind", [RK_Struct, RK_Enum]> {
  let cppNamespace = "::reussir";
}

//===----------------------------------------------------------------------===//
// LifeScope Attributes
//===----------------------------------------------------------------------===//
def LS_Global : I32EnumAttrCase<"global", 0>;
def LS_Local : I32EnumAttrCase<"local", 1>;

def LifeScope
    : I32EnumAttr<"LifeScope", "life scope", [LS_Global, LS_Local]> {
  let cppNamespace = "::reussir";
}
//===----------------------------------------------------------------------===//
// Debug Attributes
//===----------------------------------------------------------------------===//
// Debug Types
//===----------------------------------------------------------------------===//
def Reussir_DBGIntType : ReussirAttr<"DBGIntType", "dbg_inttype"> {
  let description = "Debug integer type attribute";
  let parameters = (ins 
    "::mlir::Type":$innerType, 
    "bool":$isSigned, 
    "::mlir::StringAttr":$dbgName);
  let assemblyFormat = [{
    `<` `signed` `:`  $isSigned `,` $innerType `,` `name` `:` $dbgName `>`
  }];
}
def Reussir_DBGFPType : ReussirAttr<"DBGFPType", "dbg_fptype"> {
  let description = "Debug floating point type attribute";
  let parameters = (ins "::mlir::Type":$innerType, 
                    "::mlir::StringAttr":$dbgName);
  let assemblyFormat = [{
    `<` $innerType `,` `name` `:` $dbgName `>`
  }];
}
def Reussir_DBGRecordMember : ReussirAttr<"DBGRecordMember", "dbg_record_member"> {
  let description = "Debug record type attribute";
  let parameters = (
    ins "::mlir::StringAttr":$name,
    "::mlir::Attribute":$typeAttr
  );
  let assemblyFormat = [{
    `<` `name` `:` $name `,` 
        `type` `:` $typeAttr
    `>`
  }];
}
def Reussir_DBGRecordType : ReussirAttr<"DBGRecordType", "dbg_recordtype"> {
  let description = "Debug record type attribute";
  let parameters = (ins 
    "::mlir::ArrayAttr":$members,
    "bool":$isVariant,
    "::mlir::Type":$underlyingType,
    "::mlir::StringAttr":$dbgName
  );
  let assemblyFormat = [{
    `<` 
        `members` `:` $members `,`
        `is_variant` `:` $isVariant `,`
        `underlying_type` `:` $underlyingType `,`
        `dbg_name` `:` $dbgName
    `>`
  }];
}
def Reussir_DBGSubprogram : ReussirAttr<"DBGSubprogram", "dbg_subprogram"> {
  let description = "Debug subprogram attribute";
  let parameters = (ins
    "::mlir::StringAttr":$rawName,
    "::mlir::ArrayAttr":$typeParams
    
  );
  let assemblyFormat = [{
    `<`
        `raw_name` `:` $rawName `,`
        `type_params` `:` $typeParams
    `>`
  }];
}
// TODO: we need to handle boxed type and generate DI expressions later on
// For now, let's focus on basic types and unboxed record types
def Reussir_DBGLocalVar : ReussirAttr<"DBGLocalVar", "dbg_localvar"> {
  let description = "Debug local variable attribute";
  let parameters = (ins
    "::mlir::Attribute":$dbgType,
    "::mlir::StringAttr":$varName
  );
  let assemblyFormat = [{
    `<`
        `type` `:` $dbgType `,`
        `name` `:` $varName
    `>`
  }];
}
#endif // REUSSIR_IR_REUSSIRATTRS_TD
