// RUN: %reussir-elab --mode semi %s
// RUN: %reussir-elab --mode full %s | %FileCheck %s

// CHECK-DAG: struct _RIC6MatrixyE (aka Matrix<u64>){
// CHECK-NEXT-DAG: m00: u64,
// CHECK-NEXT-DAG: m01: u64,
// CHECK-NEXT-DAG: m10: u64,
// CHECK-NEXT-DAG: m11: u64
// CHECK-NEXT-DAG: }
struct [value] Matrix<T : Num> {
    m00: T, 
    m01: T,
    m10: T, 
    m11: T
}

// CHECK-DAG: fn _RIC6matmulyE<u64>(a: _RIC6MatrixyE, b: _RIC6MatrixyE) -> _RIC6MatrixyE {
// CHECK-NEXT-DAG: let v2 (m00) : u64 = ((v0.0 : u64 * v1.0 : u64) : u64 + (v0.1 : u64 * v1.2 : u64) : u64) : u64 in
// CHECK-NEXT-DAG: let v3 (m01) : u64 = ((v0.0 : u64 * v1.1 : u64) : u64 + (v0.1 : u64 * v1.3 : u64) : u64) : u64 in
// CHECK-NEXT-DAG: let v4 (m10) : u64 = ((v0.2 : u64 * v1.0 : u64) : u64 + (v0.3 : u64 * v1.2 : u64) : u64) : u64 in
// CHECK-NEXT-DAG: let v5 (m11) : u64 = ((v0.2 : u64 * v1.1 : u64) : u64 + (v0.3 : u64 * v1.3 : u64) : u64) : u64 in
// CHECK-NEXT-DAG: compound(v2, v3, v4, v5) : _RIC6MatrixyE
// CHECK-NEXT-DAG: }

// CHECK-DAG: fn _RC13fibonacci_u64(n: u64) -> u64 {
// CHECK-NEXT-DAG: let v1 (x) : _RIC6MatrixyE = compound(0.0 : u64, 1.0 : u64, 1.0 : u64, 1.0 : u64) : _RIC6MatrixyE in
// CHECK-NEXT-DAG: let v2 (eye) : _RIC6MatrixyE = compound(1.0 : u64, 0.0 : u64, 0.0 : u64, 1.0 : u64) : _RIC6MatrixyE in
// CHECK-NEXT-DAG: fibonacci_logarithmic_impl<u64>(v0, v2, v1) : u64
// CHECK-NEXT-DAG: }

// CHECK-DAG: fn _RIC26fibonacci_logarithmic_implyE<u64>(n: u64, a: _RIC6MatrixyE, b: _RIC6MatrixyE) -> u64 {
// CHECK-NEXT-DAG: if (v0 == 0.0 : u64) : bool then
// CHECK-NEXT-DAG: v1.1 : u64
// CHECK-NEXT-DAG: else
// CHECK-NEXT-DAG: if ((v0 % 2.0 : u64) : u64 == 1.0 : u64) : bool then
// CHECK-NEXT-DAG: fibonacci_logarithmic_impl<u64>((v0 / 2.0 : u64) : u64, matmul<u64>(v1, v2) : _RIC6MatrixyE, matmul<u64>(v2, v2) : _RIC6MatrixyE) : u64
// CHECK-NEXT-DAG: else
// CHECK-NEXT-DAG: fibonacci_logarithmic_impl<u64>((v0 / 2.0 : u64) : u64, v1, matmul<u64>(v2, v2) : _RIC6MatrixyE) : u64
// CHECK-NEXT-DAG: }
fn matmul<T : Num>(a : Matrix<T>, b : Matrix<T>) -> Matrix<T> {
    let m00 = a.m00 * b.m00 + a.m01 * b.m10;
    let m01 = a.m00 * b.m01 + a.m01 * b.m11;
    let m10 = a.m10 * b.m00 + a.m11 * b.m10;
    let m11 = a.m10 * b.m01 + a.m11 * b.m11;
    Matrix<T> { m00 : m00, m01 : m01, m10 : m10, m11 : m11 }
}

fn fibonacci_logarithmic_impl<T : Integral>(
    n: T,
    a: Matrix<T>,
    b: Matrix<T>
) -> T {
    if n == 0 {
        a.m01
    } else {
        if n % 2 == 1 {
            fibonacci_logarithmic_impl<T>(
                n / 2,
                matmul(a, b),
                matmul<T>(b, b)
            )
        } else {
            fibonacci_logarithmic_impl<_>(
                n / 2,
                a,
                matmul<T>(b, b)
            )
        }
    }
}

fn fibonacci_u64(n : u64) -> u64 {
    let x = Matrix<_> { m00 : 0, m01 : 1, m10 : 1, m11 : 1 };
    let eye = Matrix<_> { m00 : 1, m01 : 0, m10 : 0, m11 : 1 };
    fibonacci_logarithmic_impl<_>(n, eye, x)
}
